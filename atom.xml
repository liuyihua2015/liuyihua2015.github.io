<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LIU YIHUA`S WORLD</title>
  
  <subtitle>移动端开发工程师</subtitle>
  <link href="https://liuyihua2015.github.io/atom.xml" rel="self"/>
  
  <link href="https://liuyihua2015.github.io/"/>
  <updated>2022-04-06T09:35:16.929Z</updated>
  <id>https://liuyihua2015.github.io/</id>
  
  <author>
    <name>liuyihua</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS高级进阶:链接与Symbol</title>
    <link href="https://liuyihua2015.github.io/2022/04/01/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/"/>
    <id>https://liuyihua2015.github.io/2022/04/01/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/</id>
    <published>2022-04-01T02:12:51.000Z</published>
    <updated>2022-04-06T09:35:16.929Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>系列文章</strong>：iOS高级进阶</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章学习的主要内容为:<strong>多环境配置，xconfig文件冲突解决，Mach-O与链接器，符号的种类与作用，strip命令</strong></p><h2 id="一、多环境配置"><a href="#一、多环境配置" class="headerlink" title="一、多环境配置"></a>一、多环境配置</h2><ul><li>Project：包含了项目所有的代码，资源文件，所有信息。</li><li>Targets：对指定代码和资源文件的具体构建方式。</li><li>Scheme：对指定Target的环境配置。</li></ul><p>我们创建好项目，项目默认两个环境<strong>Debug</strong>和<strong>Release</strong>环境，在开发过程中我们也会有两套或者多套服务器环境，每个环境的地址不同，粗糙的写法就是如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if DEBUG</span><br><span class="line">//开发环境</span><br><span class="line">#else</span><br><span class="line">//正式环境</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>它只能满足两种环境，无法适应多环境，下面我们介绍几种多环境配置方法</p><h3 id="（一）Targets进行多环境配置："><a href="#（一）Targets进行多环境配置：" class="headerlink" title="（一）Targets进行多环境配置："></a>（一）Targets进行多环境配置：</h3><p>1.在项目时可以创建多个Target，复制一个target，成为新的dev_target</p><p>2.修改一下新的target 的 bundle Id</p><p>3.修改一下新的target的info.plist文件</p><p>4.两个target 都可以运行，并且是不同的项目，可以通过 配置不同 的icon 进行区分</p><p>5.在build setting 中 设置宏</p><p>5.1 OC宏配置</p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220402100116578.png" alt="image-20220402100116578"></p><p>5.2 swift 宏配置</p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220402100001778.png" alt="image-20220402100001778"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//开发环境</span><br><span class="line">#if DEVELOPMENT == 1</span><br><span class="line"></span><br><span class="line">//生产环境</span><br><span class="line">#elif TARGET_VERSION == 0</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p> 6.总结</p><p>这种多环境配置有一个缺点: 会存在多info.plst文件，环境多了，配置会比较乱</p><h3 id="（二）对指定Target进行多Schems的环境配置，进行不同的环境编译："><a href="#（二）对指定Target进行多Schems的环境配置，进行不同的环境编译：" class="headerlink" title="（二）对指定Target进行多Schems的环境配置，进行不同的环境编译："></a>（二）对指定Target进行多Schems的环境配置，进行不同的环境编译：</h3><p>1.在Project中，首先添加需要的 Configuraction</p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220401154815934.png" alt="image-20220401154815934"></p><p>2.创建不同的schems，指定他们的Build Configuraction </p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220401152503039.png" alt="image-20220401152503039"></p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220401152549890.png" alt="image-20220401152549890"></p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220401152612833.png" alt="image-20220401152612833"></p><p>3.在build setting 中 设置宏</p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220401142048234.png" alt="image-20220401142048234"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//开发环境 可编译不同的请求地址</span><br><span class="line">#if TARGET_VERSION == 0</span><br><span class="line"></span><br><span class="line">//生产环境</span><br><span class="line">#elif TARGET_VERSION == 1</span><br><span class="line"></span><br><span class="line">//测试环境</span><br><span class="line">#elif TARGET_VERSION == 2</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>4.这样可以愉快的开发了</p><p><strong>总结：</strong>这种方式虽然不会存在多info.plst文件，但是环境多了，配置会比较乱, 修改的代码都在一起，影响主工程代码（这里可以开分支开发，不污染主分支，最后合并代码）</p><h3 id="（三）-xcconfig多环境配置："><a href="#（三）-xcconfig多环境配置：" class="headerlink" title="（三）.xcconfig多环境配置："></a>（三）.xcconfig多环境配置：</h3><h4 id="初始-xcconfig"><a href="#初始-xcconfig" class="headerlink" title="初始.xcconfig"></a><strong>初始.xcconfig</strong></h4><p>xcconfig文件正如其名字一样，就是xcode里的config文件。 我们在开发过程中，需要配置一些参数，这些都可以在xcode工程的setting对项目进行配置，xcconfig就是将这些配置项以文件的形式独立出来，方便共享与配置。比如两个项目用到相同的配置，那么只需要在xcode中选择对应的xcconfig文件即可，方便与灵活共，我们经常使用的 cocoapods 对第三方进行管理，其实就是通过.xcconfig文件进行管理的，创建好cocoapods会自动根据环境帮我们生成好.xcconfig文件。</p><blockquote><p><strong>.xcconfig文件内容是已Key-Value形式存在，’=’左侧是key值，右侧为value值</strong></p></blockquote><p>1、创建config文件</p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220402102300444.png" alt="image-20220402102300444"></p><blockquote><p><strong>注意命名规则：.xcconfig文件所在的文件夹名称+项目名称+.环境名称</strong></p></blockquote><p>2、编辑文件内容：</p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220402102823762.png" alt="image-20220402102823762"></p><p>3、回到Project中，将配置文件和schems 关联起来</p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220402102642693.png" alt="image-20220402102642693"></p><p>4、在info.plist中，配置</p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220402220838584.png" alt="image-20220402220838584"></p><p>5.需要在 <code>Build Settings</code> 中的 <code>User-Defined</code> 添加 自定义宏定义</p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220404104617855.png" alt="image-20220404104617855"></p><p>6、在项目中简单使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    NSString *path = [NSBundle.mainBundle pathForResource:@&quot;Info&quot; ofType:@&quot;plist&quot;];</span><br><span class="line">    NSDictionary *infoDic = [[NSDictionary alloc] initWithContentsOfFile:path];</span><br><span class="line">    NSLog(@&quot;%@&quot;,infoDic[@&quot;HOST_URL&quot;]);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>这种设置方式要比上面的简化了不少，但是.xcconfig文件的功能不只有这些，下面我们扩展一下</p><h2 id="二、xconfig扩展与文件冲突解决"><a href="#二、xconfig扩展与文件冲突解决" class="headerlink" title="二、xconfig扩展与文件冲突解决"></a>二、xconfig扩展与文件冲突解决</h2><h3 id="（一）-xcconfig扩展"><a href="#（一）-xcconfig扩展" class="headerlink" title="（一）.xcconfig扩展"></a>（一）.xcconfig扩展</h3><p>上面我们介绍了<code>简单的配置URL</code>，<code>.xcconfig文件</code>是可以配置<code>Build Settings</code>里面的内容，比如我们平时配置<code>动态库，静态库</code>时，要配置到<code>Other Link Flags</code>，通过<code>.xcconfig</code>我们可以<code>直接配置</code>，例如：我们配置AFN</p><ul><li>在.xcconfig中写如下代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HOST_URL=127.0.0.1</span><br><span class="line">OTHER_LDFLAGS = -framework &quot;AFNetworking&quot;</span><br></pre></td></tr></table></figure><ul><li>项目build之后，在<code>Build Settings</code>中查看 <code>Other Link Flags</code>，发现写的已经配置进去了</li><li>过上面的操作我们可以知道，<code>Build Settings</code>的所有<code>配置</code>都是可以<code>通过.xcconfig</code>文件进行<code>管理</code>的。我们来解释下.xcconfig的内容：<code>OTHER_LDFLAGS是Build Settings里面的一个缩写</code>，其它设置缩写是什么呢？</li><li>推荐个地址：<a href="https://link.juejin.cn/?target=https://xcodebuildsettings.com">Xcode Build Settings</a></li><li>比如我们想配置<code>Header Search Paths</code>，它对应的缩写：<code>HEADER_SEARCH_PATHS</code></li></ul><h3 id="（二）-xcconfig文件冲突"><a href="#（二）-xcconfig文件冲突" class="headerlink" title="（二）.xcconfig文件冲突"></a>（二）.xcconfig文件冲突</h3><p><strong>问题一</strong></p><p>我们项目都会通过<code>cocoapods管理第三方</code>，最开始介绍.xcconfig的时候，说了<code>pods</code>会自动帮我们<code>生成.xcconfig文件</code>，那此时项目中就会有<code>4个.xccongig文件</code>，直接运行会报错</p><p>解决办法：在我们自己的xccongig文件中，通过 <code>#include</code> 引入cocoapods的xccongig文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &quot;Pods/Target Support Files/Pods-LoginApp/Pods-LoginApp.debug.xcconfig&quot;</span><br><span class="line">HOST_URL = 127.0.0.1</span><br><span class="line">OTHER_LDFLAGS = -framework &quot;AFNetworking&quot;</span><br></pre></td></tr></table></figure><p><strong>问题二</strong></p><p>我们看到<code>Pods生成的.xcconfig</code>里也会有<code>OTHER_LDFLAGS</code>，我们<code>自己写的.xcconfig</code>中<code>也存在OTHER_LDFLAGS</code>，我们再去看下项目的<code>Other Linker Flags</code>，发现<code>Pods</code>生成的<code>.xcconfig没有生效</code>，那么怎么才能让我们写的和Pods生成的都生效呢？</p><ul><li><p>使用 <code>inherited</code> 进行集成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &quot;Pods/Target Support Files/Pods-LoginApp/Pods-LoginApp.debug.xcconfig&quot;</span><br><span class="line"></span><br><span class="line">HOST_URL = 127.0.0.1</span><br><span class="line"></span><br><span class="line">// ld</span><br><span class="line">// key-value</span><br><span class="line">// OTHER_LDFLAGS 缩写</span><br><span class="line">OTHER_LDFLAGS = $(inherited) -framework &quot;AFNetworking&quot;</span><br><span class="line">HEADER_SEARCH_PATHS = /use/info/inclue</span><br></pre></td></tr></table></figure></li></ul><p><strong>总结</strong></p><p>我们通过<code>.xcconfig</code>对项目进行<code>配置</code>，我们可以通过<code>.xcconfig+Scheme</code>方式进行统一管理，这样既省时，又省事。</p><h2 id="三、Mach-O与链接器"><a href="#三、Mach-O与链接器" class="headerlink" title="三、Mach-O与链接器"></a>三、Mach-O与链接器</h2><h3 id="Mach-O初识"><a href="#Mach-O初识" class="headerlink" title="Mach-O初识"></a>Mach-O初识</h3><p>【Mach-O定义】：<code>Mach-O(Mach Object)</code>是<code>macOS、iOS、iPadOS存储程序和库</code>的<code>文件格式</code>。对应系统通过应用<code>二进制接口</code>(application binary interface，缩写为<code>ABI</code>)来<code>运行该格式的文件</code>。</p><p><code>Mach-O格式</code>用来<code>替代BSD系统</code>的<code>a.out格式</code>。<code>Mach-O文件</code>格式<code>保存</code>了在<code>编译过程和链接过程</code>中<code>产生</code>的<code>机器代码和数据</code>，从而为<code>静态链接</code>和<code>动态链接</code>的代码<code>提供</code>了<code>单一文件格式</code>。</p><h3 id="查看项目的Mach-O文件"><a href="#查看项目的Mach-O文件" class="headerlink" title="查看项目的Mach-O文件"></a>查看项目的Mach-O文件</h3><p>1、当我们运行项目是，项目会生成一个.app文件</p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220406164421333.png" alt="image-20220406164421333"></p><p>2、右击查看包内容，会发现里面有个可执行文件，这个就是mach-o文件</p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220406164827102.png" alt="image-20220406164827102"></p><p>3、通过 <code>file</code> 命令来查看<code>MachODome</code>文件类型（这里用的真机，所以是<code>arm64</code>架构。）</p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220406164755322.png" alt="image-20220406164755322"></p><p><strong>执行文件的调用过程大致如下：</strong></p><p>1.调用<code>fork</code>函数，创建一个<code>process</code></p><p>2.调用<code>execve</code>或其衍生函数，在该进程上加载，执行我们的<code>Mach-O</code>文件 当我们调用时<code>execve</code>(程序加载器)，内核实际上在执行以下操作:</p><ul><li>1.将文件加载到内存</li><li>2.开始分析<code>Mach-O</code>中的<code>mach_header</code>，以确认它是有效的<code>Mach-O</code>文件</li></ul><h3 id="分析Mach-O文件"><a href="#分析Mach-O文件" class="headerlink" title="分析Mach-O文件"></a>分析Mach-O文件</h3><h5 id="Mach-O组成"><a href="#Mach-O组成" class="headerlink" title="Mach-O组成"></a>Mach-O组成</h5><h5 id="1-Mach-O-结构："><a href="#1-Mach-O-结构：" class="headerlink" title="1. Mach-O 结构："></a>1. Mach-O 结构：</h5><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220406173248660.png" alt="image-20220406173248660"></p><p><code>Mach-O</code>的主要组成部分：<code>Mach Header</code>、<code>Load Command</code>、<code>Data(__TEXT、__DATA、符号表)</code></p><h5 id="2-Mach-Header"><a href="#2-Mach-Header" class="headerlink" title="2. Mach Header"></a>2. Mach Header</h5><p><code>Mach Header</code> 里有 <code>Mach-O</code> 的<code>CUP</code>信息，以及<code>Load Command</code>的信息。可以使用 <code>otool</code> 或 <code>objdump</code> 命令来查看</p><ul><li>otool命令：<code>otool -v -h MachODome</code></li><li>objdump命令：<code>objdump --macho --private-headers MachODome</code></li></ul><p>下面就是使用objdump命令，查看的详情结果如下：在改文件中已经指定好项目入口，和已经需要引用的系统依赖库信息：</p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220406171657395.png" alt="image-20220406171657395"></p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220406171330447.png" alt="image-20220406171330447"></p><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220406171408888.png" alt="image-20220406171408888"></p><h5 id="3-Load-Command"><a href="#3-Load-Command" class="headerlink" title="3. Load Command"></a>3. Load Command</h5><p><code>Load Command</code> 包含 <code>Mach-O</code>里的<code>命令类型信息，名称和二进制文件的位置</code>（类似一本书的目录）。同样可以使用 <code>otool</code> 或 <code>objdump</code> 命令来查看</p><ul><li>otool：<code>otool -v -l a.out</code></li><li>objdump: <code>objdump --macho --private-headers MachOApp</code>(注意这里是 headers)</li><li>结果如下：</li></ul><p><img src="/images/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/image-20220406172011378.png" alt="image-20220406172011378"></p><h5 id="4-Data"><a href="#4-Data" class="headerlink" title="4. Data"></a>4. Data</h5><p><code>Data</code> 由 <code>Segment</code> 的数据组成，是 <code>Mach-O</code> 占比最多的部分，有代码有数据，比如符号表（类似一本书的具体内容）。</p><p><code>Data</code> 共三个 <code>Segment</code>，<code>__TEXT、__DATA、__LINKEDIT</code>。其中 <code>__TEXT</code> 和 <code>__DATA</code> 对应一个或多个 <code>Section</code>，<code>__LINKEDIT</code> 没有 <code>Section</code>，需要配合 <code>LC_SYMTAB</code> 来解析 <code>symbol table</code> 和 <code>string table</code>。这些里面是 <code>Mach-O</code> 的主要数据。</p><p>使用 <code>xcrun size</code> 命令来查看 <code>Data</code> 内容的分部</p><ul><li>xcrun size 命令：<code>xcrun size -x -l -m MachOApp</code></li><li>结果如下：</li></ul><h2 id="四、符号的种类与作用"><a href="#四、符号的种类与作用" class="headerlink" title="四、符号的种类与作用"></a>四、符号的种类与作用</h2><h2 id="五、strip命令"><a href="#五、strip命令" class="headerlink" title="五、strip命令"></a>五、strip命令</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;系列文章&lt;/strong&gt;：iOS高级进阶&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇文章学习</summary>
      
    
    
    
    <category term="iOS高级进阶" scheme="https://liuyihua2015.github.io/categories/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/"/>
    
    
    <category term="Symbol" scheme="https://liuyihua2015.github.io/tags/Symbol/"/>
    
    <category term="链接器" scheme="https://liuyihua2015.github.io/tags/%E9%93%BE%E6%8E%A5%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Alamofire-初体验</title>
    <link href="https://liuyihua2015.github.io/2021/12/17/Alamofire-%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://liuyihua2015.github.io/2021/12/17/Alamofire-%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2021-12-17T02:59:23.000Z</published>
    <updated>2022-04-06T01:23:58.005Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/12/17/Alamofire-%E5%88%9D%E4%BD%93%E9%AA%8C/pictureName.png" alt="pictureName"></p><blockquote><p>对于iOS开发者来说，<code>AFNetworking</code>是我们大家所熟知的，而<code>Alamofire</code>呢？<code>Alamofire</code>框架其实就是<code>AFNetworking</code>兄弟，出自于同一个作者。既是同一个作者，那么他们的使用方法，框架结构上应该也是保持一致的。<a href="https://links.jianshu.com/go?to=https://github.com/AFNetworking/AFNetworking">AFNetworking</a>、<a href="https://links.jianshu.com/go?to=https://github.com/Alamofire/Alamofire">Alamofire</a></p></blockquote><h4 id="一、回顾苹果原生网络请求"><a href="#一、回顾苹果原生网络请求" class="headerlink" title="一、回顾苹果原生网络请求"></a>一、回顾苹果原生网络请求</h4><h4 id="一、网络请求步骤"><a href="#一、网络请求步骤" class="headerlink" title="一、网络请求步骤"></a>一、网络请求步骤</h4><ol><li>设置请求<code>url</code></li><li>设置<code>URLRequest</code>对象，配置请求相关信息</li><li>创建会话配置<code>URLSessionConfiguration</code></li><li>创建会话<code>URLSession</code></li><li>创建任务和设置请求回调，并发起请求</li></ol><blockquote><p>一般通过以上几个步来完成网络请求，当然要根据不同应用场景来配置请求属性。</p></blockquote><h4 id="二、体验"><a href="#二、体验" class="headerlink" title="二、体验"></a>二、体验</h4><p>发起一个请求：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">responseData</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> url <span class="operator">=</span> <span class="string">&quot;http://onapp.yahibo.top/public/?s=api/test/list&quot;</span></span><br><span class="line">    <span class="type">Alamofire</span>.request(url).responseJSON &#123;</span><br><span class="line">        (response) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> response.result&#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> json):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;json:<span class="subst">\(json)</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">let</span> dict <span class="operator">=</span> json <span class="keyword">as!</span> <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="keyword">Any</span>&gt;</span><br><span class="line">            <span class="keyword">let</span> list <span class="operator">=</span> dict[<span class="string">&quot;data&quot;</span>] <span class="keyword">as!</span> <span class="type">Array</span>&lt;<span class="type">AnyObject</span>&gt;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> result <span class="operator">=</span> [<span class="type">UserModel1</span>].deserialize(from: list) <span class="keyword">else</span>&#123;<span class="keyword">return</span>&#125;</span><br><span class="line">            <span class="keyword">self</span>.observable.onNext(result <span class="keyword">as</span> [<span class="keyword">Any</span>])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error:<span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>responseJSON</code>为相应类型，指定为<code>json</code>数据类型</li><li><code>response</code>是<code>Alamofire</code>对服务器响应结果的封装</li><li>使用常规解包获取数据<code>headimg</code></li><li>通过<code>HandyJSON</code>转换为模型数据，供<code>UI</code>展示</li></ul><p>直接通过<code>Alamofire</code>发起请求通过一个闭包返回请求结果，不需要二次封装使用简单。这里我们没有标明请求类型，没有请求参数，那<code>Alamofire</code>是如何封装这些请求参数的呢，点击进入查看方法定义：</p><p>这里已经提供了请求所需要的参数，并设置了默认值，因此外界在没有指定方法时默认为<code>get</code>方式。根据实际开发需求设置响应的参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alamofire.request(url,method: .post,parameters: [<span class="string">&quot;page&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;size&quot;</span>:<span class="string">&quot;20&quot;</span>]).responseJSON</span><br></pre></td></tr></table></figure><p>这是我们开发中常见的设置请求方式，请求参数，这里的<code>url</code>支持多种数据类型，可以是<code>String、URL、URLRequest</code>等类型，为什么这么设计呢？因为在项目中可能当前我们跟前有一个<code>String</code>类型的连接，也有可能是个<code>URL</code>类型的连接，这时候在不需要转换的情况下就可以直接使用，方便快捷，更加灵活。</p><h4 id="三、URLSession"><a href="#三、URLSession" class="headerlink" title="三、URLSession"></a>三、URLSession</h4><p>同样在<code>Alamofire</code>中也是对<code>URLSession</code>封装的，在<code>OC</code>中为<code>NSURLSession</code>，其实是一样的。一般网络请求分三个步骤：</p><h5 id="1、设置URL请求地址"><a href="#1、设置URL请求地址" class="headerlink" title="1、设置URL请求地址"></a>1、设置URL请求地址</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = URL.<span class="keyword">init</span>(<span class="built_in">string</span>: <span class="string">&quot;协议://主机地址/路径/参数1&amp;参数2&quot;</span>)!</span><br></pre></td></tr></table></figure><ul><li>协议：指定<code>http</code>协议还是<code>https</code>协议</li><li>主机：即服务器地址<code>ip</code>地址或绑定<code>ip</code>的域名</li><li>路径：项目在服务器上的位置</li><li>参数：即<code>get</code>参数拼接在连接上</li></ul><h5 id="2、设置URLRequest属性"><a href="#2、设置URLRequest属性" class="headerlink" title="2、设置URLRequest属性"></a>2、设置URLRequest属性</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request  = URLRequest.<span class="keyword">init</span>(url: url)</span><br><span class="line">request.httpMethod = HTTPMethod.post.rawValue</span><br><span class="line">request.setValue(<span class="string">&quot;application/json&quot;</span>, forHTTPHeaderField: <span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">let postData = [<span class="string">&quot;username&quot;</span>:<span class="string">&quot;hibo&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;123456&quot;</span>]</span><br><span class="line">request.httpBody = <span class="keyword">try</span>?JSONSerialization.<span class="keyword">data</span>(withJSONObject: postData, options: [])</span><br><span class="line">request.timeoutInterval = <span class="number">30</span></span><br><span class="line">request.cachePolicy = .useProtocolCachePolicy</span><br></pre></td></tr></table></figure><ul><li><code>httpMethod</code>设置请求方式<code>post</code>或<code>get</code></li><li><code>setValue</code>设置请求头信息</li><li><code>httpBody</code>设置请求参数，参数打包在请求体中</li><li><code>timeoutInterval</code>设置请求超时时间</li><li><code>cachePolicy</code>设置网络请求缓存策略</li></ul><blockquote><p>通过以上的参数设置，能够感受到发送一次请求是多么不容易，因此网络请求是必须要被封装的</p></blockquote><h5 id="3、发起请求"><a href="#3、发起请求" class="headerlink" title="3、发起请求"></a>3、发起请求</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">URLSession.shared.dataTask(<span class="keyword">with</span>: request) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*******网络请求*******&quot;</span>)</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        let list =  <span class="keyword">try</span> JSONSerialization.jsonObject(<span class="keyword">with</span>: data!, options: .allowFragments)</span><br><span class="line">        <span class="built_in">print</span>(list)</span><br><span class="line">    &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.resume()</span><br></pre></td></tr></table></figure><ul><li><code>URLSession.shared</code>为全局共享单例会话对象</li><li>调用<code>dataTask</code>创建网络请求任务</li><li><code>resume</code>默认为挂起状态，调用重新启动网络请求任务</li><li><code>data</code>：请求到的数据流，通过<code>JSONSerialization</code>序列化为<code>json</code>格式使用</li></ul><h4 id="四、URLSessionConfiguration"><a href="#四、URLSessionConfiguration" class="headerlink" title="四、URLSessionConfiguration"></a>四、URLSessionConfiguration</h4><p>在<code>URLSession.shared</code>中内部已经配置了该项，此项为会话配置项，一般使用都会进行配置以适用于不同场景。查看该类如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> `<span class="title">default</span>`: <span class="type">URLSessionConfiguration &#123; get &#125;</span></span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">ephemeral</span>: <span class="type">URLSessionConfiguration &#123; get &#125;</span></span></span><br><span class="line"><span class="meta">@available(iOS 8.0, *)</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">background</span></span>(withIdentifier identifier: String) -&gt; URLSessionConfiguration</span><br></pre></td></tr></table></figure><ul><li><code>default</code>：默认模式，常用模式，在该模式下系统会创建持久化缓存，并在用户的钥匙串中保存证书</li><li><code>ephemeral</code>：不支持持久性存储，所有内容的会随着<code>session</code>的生命周期结束而释放</li><li><code>background</code>：与<code>default</code>模式类似，在该模式下会创建一个独立线程来传输网络请求数据，可以在后台乃至APP关闭的时候也可以进行数据传输</li></ul><p>创建一个会话：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration <span class="operator">=</span> <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">&quot;request_id&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>.<span class="keyword">init</span>(configuration: configuration, delegate: <span class="keyword">self</span>, delegateQueue: <span class="type">OperationQueue</span>.main)</span><br><span class="line">session.dataTask(with: request) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*******网络请求*******&quot;</span>)</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> list <span class="operator">=</span>  <span class="keyword">try</span> <span class="type">JSONSerialization</span>.jsonObject(with: data<span class="operator">!</span>, options: .allowFragments)</span><br><span class="line">        <span class="built_in">print</span>(list)</span><br><span class="line">    &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.resume()</span><br></pre></td></tr></table></figure><ul><li>设置一个唯一会话标识，通过标识来区分不同的会话任务</li><li>遵循<code>URLSessionDelegate</code>代理，实现代理方法，在本类中监控任务进度</li></ul><p>下载任务：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration <span class="operator">=</span> <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">&quot;request_id&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>.<span class="keyword">init</span>(configuration: configuration, delegate: <span class="keyword">self</span>, delegateQueue: <span class="type">OperationQueue</span>.main)</span><br><span class="line">session.downloadTask(with: url).resume()</span><br></pre></td></tr></table></figure><p><strong>注意在使用<code>background</code>模式时一定要开启后台下载权限，否则无法完成后台下载并回调数据。</strong>需要以下两步才能完成：</p><p>1、开启后台下载权限</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> backgroundHandler: (()-&gt;<span class="type">Void</span>)<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">//设置此处开启后台下载权限</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">handleEventsForBackgroundURLSession</span> <span class="params">identifier</span>: <span class="type">String</span>, <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.backgroundHandler <span class="operator">=</span> completionHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、实现<code>SessionDelegate</code>代理方法，调用闭包方法，通知系统更新屏幕</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">urlSessionDidFinishEvents</span>(<span class="params">forBackgroundURLSession</span> <span class="params">session</span>: <span class="type">URLSession</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;后台任务下载回来&quot;</span>)</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> appDelegate <span class="operator">=</span> <span class="type">UIApplication</span>.shared.delegate <span class="keyword">as?</span> <span class="type">AppDelegate</span>, <span class="keyword">let</span> backgroundHandle <span class="operator">=</span> appDelegate.backgroundHandler <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        backgroundHandle()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>苹果官方给出需要实现以上两个方法来完成后台下载，通知系统及时更新屏幕。<a href="https://links.jianshu.com/go?to=%5Bhttps://developer.apple.com/documentation/foundation/nsurlsessiondelegate/1617185-urlsessiondidfinisheventsforback?language=objc%5D(https://developer.apple.com/documentation/foundation/nsurlsessiondelegate/1617185-urlsessiondidfinisheventsforback?language=objc)">官方文档</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2021/12/17/Alamofire-%E5%88%9D%E4%BD%93%E9%AA%8C/pictureName.png&quot; alt=&quot;pictureName&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于iOS开发者来说，&lt;code&gt;AFNe</summary>
      
    
    
    
    <category term="网络框架" scheme="https://liuyihua2015.github.io/categories/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Alamofire" scheme="https://liuyihua2015.github.io/tags/Alamofire/"/>
    
    <category term="swift" scheme="https://liuyihua2015.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 有效的插件</title>
    <link href="https://liuyihua2015.github.io/2021/12/17/Hexo%20%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E9%A2%84%E8%A7%88/"/>
    <id>https://liuyihua2015.github.io/2021/12/17/Hexo%20%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E9%A2%84%E8%A7%88/</id>
    <published>2021-12-17T02:59:23.000Z</published>
    <updated>2022-04-01T09:36:04.622Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、实现实时预览编辑"><a href="#一、实现实时预览编辑" class="headerlink" title="一、实现实时预览编辑"></a>一、实现实时预览编辑</h3><p>在用了一段时间 Hexo 后, 发现写 Hexo 文章时需要到在线的 Markdown 编辑器中实时预览, 感觉还是有些不方便.</p><p>在网上一番寻找之后, 发现了一个插件: <a href="https://github.com/hexojs/hexo-browsersync/">hexo-browsersync</a>, 这是一个移植插件, 项目主页上基本没有过多的介绍. 下面写一些我自己使用的心得吧.</p><h4 id="Hexo-Browsersync-使用方法"><a href="#Hexo-Browsersync-使用方法" class="headerlink" title="Hexo-Browsersync 使用方法"></a>Hexo-Browsersync 使用方法</h4><p>首先在项目目录下安装 <code>hexo-browsersync</code> 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo_project/</span><br><span class="line">$ npm install hexo-browsersync --save</span><br></pre></td></tr></table></figure><p>然后运行 hexo server, 看到以下内容就说明启动成功啦.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br><span class="line">[BS] Access URLs:</span><br><span class="line"> --------------------------------------</span><br><span class="line">          UI: http://localhost:3001</span><br><span class="line"> --------------------------------------</span><br><span class="line"> UI External: http://192.168.191.1:3001</span><br><span class="line"> --------------------------------------</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>其中 3001 端口是 browsersync 的配置页面, 4000 端口就是我们的调试页面了.</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://yq.aliyun.com/articles/3060">Hexo Server 的一个迷の bug</a> – 潘佳邦</li><li><a href="https://github.com/hexojs/hexo-browsersync/issues/12">https://github.com/hexojs/hexo-browsersync/issues/12</a></li></ul><h3 id="二、图片插件"><a href="#二、图片插件" class="headerlink" title="二、图片插件"></a>二、图片插件</h3><p>插件<strong>hexo-renderer-marked</strong>解决了这个问题。可以只用<strong>npm install hexo-renderer-marked</strong>命令直接安装，之后在<strong>config.yaml</strong>中更改配置如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="symbol">marked:</span></span><br><span class="line">  <span class="symbol">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="symbol">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>之后就可以在使用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure><p>的方式愉快的插入图片了。</p><p>我们做了这么多都是为了方便，那么为什么不再方便一点呢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、实现实时预览编辑&quot;&gt;&lt;a href=&quot;#一、实现实时预览编辑&quot; class=&quot;headerlink&quot; title=&quot;一、实现实时预览编辑&quot;&gt;&lt;/a&gt;一、实现实时预览编辑&lt;/h3&gt;&lt;p&gt;在用了一段时间 Hexo 后, 发现写 Hexo 文章时需要到在线的 Mar</summary>
      
    
    
    
    <category term="心得" scheme="https://liuyihua2015.github.io/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Hexo" scheme="https://liuyihua2015.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
