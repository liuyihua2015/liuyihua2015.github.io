<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LIU YIHUA`S WORLD</title>
  
  <subtitle>移动端开发工程师</subtitle>
  <link href="https://liuyihua2015.github.io/atom.xml" rel="self"/>
  
  <link href="https://liuyihua2015.github.io/"/>
  <updated>2021-12-17T08:14:29.262Z</updated>
  <id>https://liuyihua2015.github.io/</id>
  
  <author>
    <name>liuyihua</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo 有效的插件</title>
    <link href="https://liuyihua2015.github.io/2021/12/17/Hexo%20%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E9%A2%84%E8%A7%88/"/>
    <id>https://liuyihua2015.github.io/2021/12/17/Hexo%20%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E9%A2%84%E8%A7%88/</id>
    <published>2021-12-17T02:59:23.000Z</published>
    <updated>2021-12-17T08:14:29.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、实现实时预览编辑"><a href="#一、实现实时预览编辑" class="headerlink" title="一、实现实时预览编辑"></a>一、实现实时预览编辑</h3><p>在用了一段时间 Hexo 后, 发现写 Hexo 文章时需要到在线的 Markdown 编辑器中实时预览, 感觉还是有些不方便.</p><p>在网上一番寻找之后, 发现了一个插件: <a href="https://github.com/hexojs/hexo-browsersync/">hexo-browsersync</a>, 这是一个移植插件, 项目主页上基本没有过多的介绍. 下面写一些我自己使用的心得吧.</p><h4 id="Hexo-Browsersync-使用方法"><a href="#Hexo-Browsersync-使用方法" class="headerlink" title="Hexo-Browsersync 使用方法"></a>Hexo-Browsersync 使用方法</h4><p>首先在项目目录下安装 <code>hexo-browsersync</code> 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo_project/</span><br><span class="line">$ npm install hexo-browsersync --save</span><br></pre></td></tr></table></figure><p>然后运行 hexo server, 看到以下内容就说明启动成功啦.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br><span class="line">[BS] Access URLs:</span><br><span class="line"> --------------------------------------</span><br><span class="line">          UI: http://localhost:3001</span><br><span class="line"> --------------------------------------</span><br><span class="line"> UI External: http://192.168.191.1:3001</span><br><span class="line"> --------------------------------------</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>其中 3001 端口是 browsersync 的配置页面, 4000 端口就是我们的调试页面了.</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://yq.aliyun.com/articles/3060">Hexo Server 的一个迷の bug</a> – 潘佳邦</li><li><a href="https://github.com/hexojs/hexo-browsersync/issues/12">https://github.com/hexojs/hexo-browsersync/issues/12</a></li></ul><h3 id="二、图片插件"><a href="#二、图片插件" class="headerlink" title="二、图片插件"></a>二、图片插件</h3><p>插件<strong>hexo-renderer-marked</strong>解决了这个问题。可以只用<strong>npm install hexo-renderer-marked</strong>命令直接安装，之后在<strong>config.yaml</strong>中更改配置如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="symbol">marked:</span></span><br><span class="line">  <span class="symbol">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="symbol">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>之后就可以在使用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure><p>的方式愉快的插入图片了。</p><p>我们做了这么多都是为了方便，那么为什么不再方便一点呢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、实现实时预览编辑&quot;&gt;&lt;a href=&quot;#一、实现实时预览编辑&quot; class=&quot;headerlink&quot; title=&quot;一、实现实时预览编辑&quot;&gt;&lt;/a&gt;一、实现实时预览编辑&lt;/h3&gt;&lt;p&gt;在用了一段时间 Hexo 后, 发现写 Hexo 文章时需要到在线的 Mar</summary>
      
    
    
    
    <category term="心得" scheme="https://liuyihua2015.github.io/categories/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="Hexo" scheme="https://liuyihua2015.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Alamofire-初体验</title>
    <link href="https://liuyihua2015.github.io/2021/12/17/Alamofire-%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://liuyihua2015.github.io/2021/12/17/Alamofire-%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2021-12-17T02:59:23.000Z</published>
    <updated>2021-12-17T08:16:27.994Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2021/12/17/Alamofire-%E5%88%9D%E4%BD%93%E9%AA%8C/pictureName.png" alt="pictureName"></p><blockquote><p>对于iOS开发者来说，<code>AFNetworking</code>是我们大家所熟知的，而<code>Alamofire</code>呢？<code>Alamofire</code>框架其实就是<code>AFNetworking</code>兄弟，出自于同一个作者。既是同一个作者，那么他们的使用方法，框架结构上应该也是保持一致的。<a href="https://links.jianshu.com/go?to=https://github.com/AFNetworking/AFNetworking">AFNetworking</a>、<a href="https://links.jianshu.com/go?to=https://github.com/Alamofire/Alamofire">Alamofire</a></p></blockquote><h4 id="一、回顾苹果原生网络请求"><a href="#一、回顾苹果原生网络请求" class="headerlink" title="一、回顾苹果原生网络请求"></a>一、回顾苹果原生网络请求</h4><h4 id="一、网络请求步骤"><a href="#一、网络请求步骤" class="headerlink" title="一、网络请求步骤"></a>一、网络请求步骤</h4><ol><li>设置请求<code>url</code></li><li>设置<code>URLRequest</code>对象，配置请求相关信息</li><li>创建会话配置<code>URLSessionConfiguration</code></li><li>创建会话<code>URLSession</code></li><li>创建任务和设置请求回调，并发起请求</li></ol><blockquote><p>一般通过以上几个步来完成网络请求，当然要根据不同应用场景来配置请求属性。</p></blockquote><h4 id="二、体验"><a href="#二、体验" class="headerlink" title="二、体验"></a>二、体验</h4><p>发起一个请求：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">responseData</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> url <span class="operator">=</span> <span class="string">&quot;http://onapp.yahibo.top/public/?s=api/test/list&quot;</span></span><br><span class="line">    <span class="type">Alamofire</span>.request(url).responseJSON &#123;</span><br><span class="line">        (response) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> response.result&#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> json):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;json:<span class="subst">\(json)</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">let</span> dict <span class="operator">=</span> json <span class="keyword">as!</span> <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="keyword">Any</span>&gt;</span><br><span class="line">            <span class="keyword">let</span> list <span class="operator">=</span> dict[<span class="string">&quot;data&quot;</span>] <span class="keyword">as!</span> <span class="type">Array</span>&lt;<span class="type">AnyObject</span>&gt;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> result <span class="operator">=</span> [<span class="type">UserModel1</span>].deserialize(from: list) <span class="keyword">else</span>&#123;<span class="keyword">return</span>&#125;</span><br><span class="line">            <span class="keyword">self</span>.observable.onNext(result <span class="keyword">as</span> [<span class="keyword">Any</span>])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error:<span class="subst">\(error)</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>responseJSON</code>为相应类型，指定为<code>json</code>数据类型</li><li><code>response</code>是<code>Alamofire</code>对服务器响应结果的封装</li><li>使用常规解包获取数据<code>headimg</code></li><li>通过<code>HandyJSON</code>转换为模型数据，供<code>UI</code>展示</li></ul><p>直接通过<code>Alamofire</code>发起请求通过一个闭包返回请求结果，不需要二次封装使用简单。这里我们没有标明请求类型，没有请求参数，那<code>Alamofire</code>是如何封装这些请求参数的呢，点击进入查看方法定义：</p><p>这里已经提供了请求所需要的参数，并设置了默认值，因此外界在没有指定方法时默认为<code>get</code>方式。根据实际开发需求设置响应的参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alamofire.request(url,method: .post,parameters: [<span class="string">&quot;page&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;size&quot;</span>:<span class="string">&quot;20&quot;</span>]).responseJSON</span><br></pre></td></tr></table></figure><p>这是我们开发中常见的设置请求方式，请求参数，这里的<code>url</code>支持多种数据类型，可以是<code>String、URL、URLRequest</code>等类型，为什么这么设计呢？因为在项目中可能当前我们跟前有一个<code>String</code>类型的连接，也有可能是个<code>URL</code>类型的连接，这时候在不需要转换的情况下就可以直接使用，方便快捷，更加灵活。</p><h4 id="三、URLSession"><a href="#三、URLSession" class="headerlink" title="三、URLSession"></a>三、URLSession</h4><p>同样在<code>Alamofire</code>中也是对<code>URLSession</code>封装的，在<code>OC</code>中为<code>NSURLSession</code>，其实是一样的。一般网络请求分三个步骤：</p><h5 id="1、设置URL请求地址"><a href="#1、设置URL请求地址" class="headerlink" title="1、设置URL请求地址"></a>1、设置URL请求地址</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = URL.<span class="keyword">init</span>(<span class="built_in">string</span>: <span class="string">&quot;协议://主机地址/路径/参数1&amp;参数2&quot;</span>)!</span><br></pre></td></tr></table></figure><ul><li>协议：指定<code>http</code>协议还是<code>https</code>协议</li><li>主机：即服务器地址<code>ip</code>地址或绑定<code>ip</code>的域名</li><li>路径：项目在服务器上的位置</li><li>参数：即<code>get</code>参数拼接在连接上</li></ul><h5 id="2、设置URLRequest属性"><a href="#2、设置URLRequest属性" class="headerlink" title="2、设置URLRequest属性"></a>2、设置URLRequest属性</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> request  = URLRequest.<span class="keyword">init</span>(url: url)</span><br><span class="line">request.httpMethod = HTTPMethod.post.rawValue</span><br><span class="line">request.setValue(<span class="string">&quot;application/json&quot;</span>, forHTTPHeaderField: <span class="string">&quot;Content-Type&quot;</span>)</span><br><span class="line">let postData = [<span class="string">&quot;username&quot;</span>:<span class="string">&quot;hibo&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;123456&quot;</span>]</span><br><span class="line">request.httpBody = <span class="keyword">try</span>?JSONSerialization.<span class="keyword">data</span>(withJSONObject: postData, options: [])</span><br><span class="line">request.timeoutInterval = <span class="number">30</span></span><br><span class="line">request.cachePolicy = .useProtocolCachePolicy</span><br></pre></td></tr></table></figure><ul><li><code>httpMethod</code>设置请求方式<code>post</code>或<code>get</code></li><li><code>setValue</code>设置请求头信息</li><li><code>httpBody</code>设置请求参数，参数打包在请求体中</li><li><code>timeoutInterval</code>设置请求超时时间</li><li><code>cachePolicy</code>设置网络请求缓存策略</li></ul><blockquote><p>通过以上的参数设置，能够感受到发送一次请求是多么不容易，因此网络请求是必须要被封装的</p></blockquote><h5 id="3、发起请求"><a href="#3、发起请求" class="headerlink" title="3、发起请求"></a>3、发起请求</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">URLSession.shared.dataTask(<span class="keyword">with</span>: request) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*******网络请求*******&quot;</span>)</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        let list =  <span class="keyword">try</span> JSONSerialization.jsonObject(<span class="keyword">with</span>: data!, options: .allowFragments)</span><br><span class="line">        <span class="built_in">print</span>(list)</span><br><span class="line">    &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.resume()</span><br></pre></td></tr></table></figure><ul><li><code>URLSession.shared</code>为全局共享单例会话对象</li><li>调用<code>dataTask</code>创建网络请求任务</li><li><code>resume</code>默认为挂起状态，调用重新启动网络请求任务</li><li><code>data</code>：请求到的数据流，通过<code>JSONSerialization</code>序列化为<code>json</code>格式使用</li></ul><h4 id="四、URLSessionConfiguration"><a href="#四、URLSessionConfiguration" class="headerlink" title="四、URLSessionConfiguration"></a>四、URLSessionConfiguration</h4><p>在<code>URLSession.shared</code>中内部已经配置了该项，此项为会话配置项，一般使用都会进行配置以适用于不同场景。查看该类如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> `<span class="title">default</span>`: <span class="type">URLSessionConfiguration &#123; get &#125;</span></span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">ephemeral</span>: <span class="type">URLSessionConfiguration &#123; get &#125;</span></span></span><br><span class="line"><span class="meta">@available(iOS 8.0, *)</span></span><br><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">background</span></span>(withIdentifier identifier: String) -&gt; URLSessionConfiguration</span><br></pre></td></tr></table></figure><ul><li><code>default</code>：默认模式，常用模式，在该模式下系统会创建持久化缓存，并在用户的钥匙串中保存证书</li><li><code>ephemeral</code>：不支持持久性存储，所有内容的会随着<code>session</code>的生命周期结束而释放</li><li><code>background</code>：与<code>default</code>模式类似，在该模式下会创建一个独立线程来传输网络请求数据，可以在后台乃至APP关闭的时候也可以进行数据传输</li></ul><p>创建一个会话：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration <span class="operator">=</span> <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">&quot;request_id&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>.<span class="keyword">init</span>(configuration: configuration, delegate: <span class="keyword">self</span>, delegateQueue: <span class="type">OperationQueue</span>.main)</span><br><span class="line">session.dataTask(with: request) &#123; (data, response, error) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*******网络请求*******&quot;</span>)</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> list <span class="operator">=</span>  <span class="keyword">try</span> <span class="type">JSONSerialization</span>.jsonObject(with: data<span class="operator">!</span>, options: .allowFragments)</span><br><span class="line">        <span class="built_in">print</span>(list)</span><br><span class="line">    &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.resume()</span><br></pre></td></tr></table></figure><ul><li>设置一个唯一会话标识，通过标识来区分不同的会话任务</li><li>遵循<code>URLSessionDelegate</code>代理，实现代理方法，在本类中监控任务进度</li></ul><p>下载任务：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration <span class="operator">=</span> <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">&quot;request_id&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> session <span class="operator">=</span> <span class="type">URLSession</span>.<span class="keyword">init</span>(configuration: configuration, delegate: <span class="keyword">self</span>, delegateQueue: <span class="type">OperationQueue</span>.main)</span><br><span class="line">session.downloadTask(with: url).resume()</span><br></pre></td></tr></table></figure><p><strong>注意在使用<code>background</code>模式时一定要开启后台下载权限，否则无法完成后台下载并回调数据。</strong>需要以下两步才能完成：</p><p>1、开启后台下载权限</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> backgroundHandler: (()-&gt;<span class="type">Void</span>)<span class="operator">?</span> <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"><span class="comment">//设置此处开启后台下载权限</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span>(<span class="keyword">_</span> <span class="params">application</span>: <span class="type">UIApplication</span>, <span class="params">handleEventsForBackgroundURLSession</span> <span class="params">identifier</span>: <span class="type">String</span>, <span class="params">completionHandler</span>: <span class="keyword">@escaping</span> () -&gt; <span class="type">Void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.backgroundHandler <span class="operator">=</span> completionHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、实现<code>SessionDelegate</code>代理方法，调用闭包方法，通知系统更新屏幕</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">urlSessionDidFinishEvents</span>(<span class="params">forBackgroundURLSession</span> <span class="params">session</span>: <span class="type">URLSession</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;后台任务下载回来&quot;</span>)</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> appDelegate <span class="operator">=</span> <span class="type">UIApplication</span>.shared.delegate <span class="keyword">as?</span> <span class="type">AppDelegate</span>, <span class="keyword">let</span> backgroundHandle <span class="operator">=</span> appDelegate.backgroundHandler <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        backgroundHandle()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>苹果官方给出需要实现以上两个方法来完成后台下载，通知系统及时更新屏幕。<a href="https://links.jianshu.com/go?to=%5Bhttps://developer.apple.com/documentation/foundation/nsurlsessiondelegate/1617185-urlsessiondidfinisheventsforback?language=objc%5D(https://developer.apple.com/documentation/foundation/nsurlsessiondelegate/1617185-urlsessiondidfinisheventsforback?language=objc)">官方文档</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2021/12/17/Alamofire-%E5%88%9D%E4%BD%93%E9%AA%8C/pictureName.png&quot; alt=&quot;pictureName&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于iOS开发者来说，&lt;code&gt;AFNe</summary>
      
    
    
    
    <category term="网络框架" scheme="https://liuyihua2015.github.io/categories/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Alamofire" scheme="https://liuyihua2015.github.io/tags/Alamofire/"/>
    
    <category term="swift" scheme="https://liuyihua2015.github.io/tags/swift/"/>
    
  </entry>
  
</feed>
