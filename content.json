{"meta":{"title":"LIU YIHUA`S WORLD","subtitle":"移动端开发工程师","description":"LIU YIHUA`S WORLD 一个记录记录学习和生活的交流平台","author":"liuyihua","url":"https://liuyihua2015.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-12-09T06:58:39.039Z","updated":"2021-12-09T06:32:05.614Z","comments":false,"path":"/404.html","permalink":"https://liuyihua2015.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-12-09T06:58:39.023Z","updated":"2021-12-09T06:32:05.615Z","comments":false,"path":"about/index.html","permalink":"https://liuyihua2015.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-12-09T06:58:39.006Z","updated":"2021-12-09T06:32:05.615Z","comments":false,"path":"books/index.html","permalink":"https://liuyihua2015.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-12-09T06:58:38.990Z","updated":"2021-12-09T06:32:05.615Z","comments":false,"path":"categories/index.html","permalink":"https://liuyihua2015.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-12-09T06:58:38.975Z","updated":"2021-12-09T06:32:05.615Z","comments":true,"path":"links/index.html","permalink":"https://liuyihua2015.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-12-09T06:58:38.958Z","updated":"2021-12-09T06:32:05.615Z","comments":false,"path":"repository/index.html","permalink":"https://liuyihua2015.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-12-09T06:58:38.941Z","updated":"2021-12-09T06:32:05.615Z","comments":false,"path":"tags/index.html","permalink":"https://liuyihua2015.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS高级进阶:链接与Symbol","slug":"iOS高级进阶-链接与Symbol","date":"2022-04-01T02:12:51.000Z","updated":"2022-04-01T08:02:03.281Z","comments":true,"path":"2022/04/01/iOS高级进阶-链接与Symbol/","link":"","permalink":"https://liuyihua2015.github.io/2022/04/01/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/","excerpt":"","text":"系列文章：iOS高级进阶 前言本篇文章学习的主要内容为:多环境配置，xconfig文件冲突解决，Mach-O与链接器，符号的种类与作用，strip命令 一、多环境配置 Project：包含了项目所有的代码，资源文件，所有信息。 Targets：对指定代码和资源文件的具体构建方式。 Scheme：对指定Target的环境配置。 我们创建好项目，项目默认两个环境Debug和Release环境，在开发过程中我们也会有两套或者多套服务器环境，每个环境的地址不同，粗糙的写法就是如下图所示： 12345#if DEBUG//开发环境#else//正式环境#endif 它只能满足两种环境，无法适应多环境，下面我们介绍几种多环境配置方法 （一）Targets进行多环境配置：1.在项目时可以创建多个Target，复制一个target，成为新的dev_target 2.修改一下新的target 的 bundle Id 3.修改一下新的target的info.plist文件 4.两个target 都可以运行，并且是不同的项目，可以通过 配置不同 的icon 进行区分 5.在build setting 中 设置宏 12345678910//开发环境#if TARGET_VERSION == 0//生产环境#elif TARGET_VERSION == 1//测试环境#elif TARGET_VERSION == 2#endif 6.总结 这种多环境配置有一个缺点: 会存在多info.plst文件，环境多了，配置会比较乱 （二）单个Target进行多Schems配置，不同的编译环境：1.在Project中，首先添加需要的 Configuraction 2.创建不同的schems，指定他们的Build Configuraction 3.在build setting 中 设置宏 12345678910//开发环境 可编译不同的请求地址#if TARGET_VERSION == 0//生产环境#elif TARGET_VERSION == 1//测试环境#elif TARGET_VERSION == 2#endif 4.这样可以愉快的开发了 总结：这种方式虽然不会存在多info.plst文件，但是环境多了，配置会比较乱, 修改的代码都在一起，影响主工程代码（这里可以开分支开发，不污染主分支，最后合并代码） （二）单个Target进行多Schems配置，不同的编译环境：二、xconfig文件冲突解决三、Mach-O与链接器四、符号的种类与作用五、strip命令","categories":[{"name":"iOS高级进阶","slug":"iOS高级进阶","permalink":"https://liuyihua2015.github.io/categories/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"Symbol","slug":"Symbol","permalink":"https://liuyihua2015.github.io/tags/Symbol/"},{"name":"链接器","slug":"链接器","permalink":"https://liuyihua2015.github.io/tags/%E9%93%BE%E6%8E%A5%E5%99%A8/"}]},{"title":"Alamofire-初体验","slug":"Alamofire-初体验","date":"2021-12-17T02:59:23.000Z","updated":"2021-12-17T08:16:27.994Z","comments":true,"path":"2021/12/17/Alamofire-初体验/","link":"","permalink":"https://liuyihua2015.github.io/2021/12/17/Alamofire-%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"","text":"对于iOS开发者来说，AFNetworking是我们大家所熟知的，而Alamofire呢？Alamofire框架其实就是AFNetworking兄弟，出自于同一个作者。既是同一个作者，那么他们的使用方法，框架结构上应该也是保持一致的。AFNetworking、Alamofire 一、回顾苹果原生网络请求一、网络请求步骤 设置请求url 设置URLRequest对象，配置请求相关信息 创建会话配置URLSessionConfiguration 创建会话URLSession 创建任务和设置请求回调，并发起请求 一般通过以上几个步来完成网络请求，当然要根据不同应用场景来配置请求属性。 二、体验发起一个请求： 123456789101112131415161718func responseData() &#123; let url = &quot;http://onapp.yahibo.top/public/?s=api/test/list&quot; Alamofire.request(url).responseJSON &#123; (response) in switch response.result&#123; case .success(let json): print(&quot;json:\\(json)&quot;) let dict = json as! Dictionary&lt;String, Any&gt; let list = dict[&quot;data&quot;] as! Array&lt;AnyObject&gt; guard let result = [UserModel1].deserialize(from: list) else&#123;return&#125; self.observable.onNext(result as [Any]) break case .failure(let error): print(&quot;error:\\(error)&quot;) break &#125; &#125;&#125; responseJSON为相应类型，指定为json数据类型 response是Alamofire对服务器响应结果的封装 使用常规解包获取数据headimg 通过HandyJSON转换为模型数据，供UI展示 直接通过Alamofire发起请求通过一个闭包返回请求结果，不需要二次封装使用简单。这里我们没有标明请求类型，没有请求参数，那Alamofire是如何封装这些请求参数的呢，点击进入查看方法定义： 这里已经提供了请求所需要的参数，并设置了默认值，因此外界在没有指定方法时默认为get方式。根据实际开发需求设置响应的参数： 1Alamofire.request(url,method: .post,parameters: [&quot;page&quot;:&quot;1&quot;,&quot;size&quot;:&quot;20&quot;]).responseJSON 这是我们开发中常见的设置请求方式，请求参数，这里的url支持多种数据类型，可以是String、URL、URLRequest等类型，为什么这么设计呢？因为在项目中可能当前我们跟前有一个String类型的连接，也有可能是个URL类型的连接，这时候在不需要转换的情况下就可以直接使用，方便快捷，更加灵活。 三、URLSession同样在Alamofire中也是对URLSession封装的，在OC中为NSURLSession，其实是一样的。一般网络请求分三个步骤： 1、设置URL请求地址1let url = URL.init(string: &quot;协议://主机地址/路径/参数1&amp;参数2&quot;)! 协议：指定http协议还是https协议 主机：即服务器地址ip地址或绑定ip的域名 路径：项目在服务器上的位置 参数：即get参数拼接在连接上 2、设置URLRequest属性1234567var request = URLRequest.init(url: url)request.httpMethod = HTTPMethod.post.rawValuerequest.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)let postData = [&quot;username&quot;:&quot;hibo&quot;,&quot;password&quot;:&quot;123456&quot;]request.httpBody = try?JSONSerialization.data(withJSONObject: postData, options: [])request.timeoutInterval = 30request.cachePolicy = .useProtocolCachePolicy httpMethod设置请求方式post或get setValue设置请求头信息 httpBody设置请求参数，参数打包在请求体中 timeoutInterval设置请求超时时间 cachePolicy设置网络请求缓存策略 通过以上的参数设置，能够感受到发送一次请求是多么不容易，因此网络请求是必须要被封装的 3、发起请求123456789URLSession.shared.dataTask(with: request) &#123; (data, response, error) in print(&quot;*******网络请求*******&quot;) do &#123; let list = try JSONSerialization.jsonObject(with: data!, options: .allowFragments) print(list) &#125;catch&#123; print(error) &#125;&#125;.resume() URLSession.shared为全局共享单例会话对象 调用dataTask创建网络请求任务 resume默认为挂起状态，调用重新启动网络请求任务 data：请求到的数据流，通过JSONSerialization序列化为json格式使用 四、URLSessionConfiguration在URLSession.shared中内部已经配置了该项，此项为会话配置项，一般使用都会进行配置以适用于不同场景。查看该类如下： 1234open class var `default`: URLSessionConfiguration &#123; get &#125;open class var ephemeral: URLSessionConfiguration &#123; get &#125;@available(iOS 8.0, *)open class func background(withIdentifier identifier: String) -&gt; URLSessionConfiguration default：默认模式，常用模式，在该模式下系统会创建持久化缓存，并在用户的钥匙串中保存证书 ephemeral：不支持持久性存储，所有内容的会随着session的生命周期结束而释放 background：与default模式类似，在该模式下会创建一个独立线程来传输网络请求数据，可以在后台乃至APP关闭的时候也可以进行数据传输 创建一个会话： 1234567891011let configuration = URLSessionConfiguration.background(withIdentifier: &quot;request_id&quot;)let session = URLSession.init(configuration: configuration, delegate: self, delegateQueue: OperationQueue.main)session.dataTask(with: request) &#123; (data, response, error) in print(&quot;*******网络请求*******&quot;) do &#123; let list = try JSONSerialization.jsonObject(with: data!, options: .allowFragments) print(list) &#125;catch&#123; print(error) &#125;&#125;.resume() 设置一个唯一会话标识，通过标识来区分不同的会话任务 遵循URLSessionDelegate代理，实现代理方法，在本类中监控任务进度 下载任务： 123let configuration = URLSessionConfiguration.background(withIdentifier: &quot;request_id&quot;)let session = URLSession.init(configuration: configuration, delegate: self, delegateQueue: OperationQueue.main)session.downloadTask(with: url).resume() 注意在使用background模式时一定要开启后台下载权限，否则无法完成后台下载并回调数据。需要以下两步才能完成： 1、开启后台下载权限 12345var backgroundHandler: (()-&gt;Void)? = nil//设置此处开启后台下载权限func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -&gt; Void) &#123; self.backgroundHandler = completionHandler&#125; 2、实现SessionDelegate代理方法，调用闭包方法，通知系统更新屏幕 1234567func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) &#123; print(&quot;后台任务下载回来&quot;) DispatchQueue.main.async &#123; guard let appDelegate = UIApplication.shared.delegate as? AppDelegate, let backgroundHandle = appDelegate.backgroundHandler else &#123; return &#125; backgroundHandle() &#125;&#125; 苹果官方给出需要实现以上两个方法来完成后台下载，通知系统及时更新屏幕。官方文档","categories":[{"name":"网络框架","slug":"网络框架","permalink":"https://liuyihua2015.github.io/categories/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Alamofire","slug":"Alamofire","permalink":"https://liuyihua2015.github.io/tags/Alamofire/"},{"name":"swift","slug":"swift","permalink":"https://liuyihua2015.github.io/tags/swift/"}]},{"title":"Hexo 有效的插件","slug":"Hexo 实现实时预览","date":"2021-12-17T02:59:23.000Z","updated":"2021-12-17T08:14:29.262Z","comments":true,"path":"2021/12/17/Hexo 实现实时预览/","link":"","permalink":"https://liuyihua2015.github.io/2021/12/17/Hexo%20%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E9%A2%84%E8%A7%88/","excerpt":"","text":"一、实现实时预览编辑在用了一段时间 Hexo 后, 发现写 Hexo 文章时需要到在线的 Markdown 编辑器中实时预览, 感觉还是有些不方便. 在网上一番寻找之后, 发现了一个插件: hexo-browsersync, 这是一个移植插件, 项目主页上基本没有过多的介绍. 下面写一些我自己使用的心得吧. Hexo-Browsersync 使用方法首先在项目目录下安装 hexo-browsersync 插件 12$ cd hexo_project/$ npm install hexo-browsersync --save 然后运行 hexo server, 看到以下内容就说明启动成功啦. 123456789$ hexo s[BS] Access URLs: -------------------------------------- UI: http://localhost:3001 -------------------------------------- UI External: http://192.168.191.1:3001 --------------------------------------INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 其中 3001 端口是 browsersync 的配置页面, 4000 端口就是我们的调试页面了. 参考文章 Hexo Server 的一个迷の bug – 潘佳邦 https://github.com/hexojs/hexo-browsersync/issues/12 二、图片插件插件hexo-renderer-marked解决了这个问题。可以只用npm install hexo-renderer-marked命令直接安装，之后在config.yaml中更改配置如下： 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 之后就可以在使用 1![](image.jpg) 的方式愉快的插入图片了。 我们做了这么多都是为了方便，那么为什么不再方便一点呢。","categories":[{"name":"心得","slug":"心得","permalink":"https://liuyihua2015.github.io/categories/%E5%BF%83%E5%BE%97/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://liuyihua2015.github.io/tags/Hexo/"}]}],"categories":[{"name":"iOS高级进阶","slug":"iOS高级进阶","permalink":"https://liuyihua2015.github.io/categories/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/"},{"name":"网络框架","slug":"网络框架","permalink":"https://liuyihua2015.github.io/categories/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"},{"name":"心得","slug":"心得","permalink":"https://liuyihua2015.github.io/categories/%E5%BF%83%E5%BE%97/"}],"tags":[{"name":"Symbol","slug":"Symbol","permalink":"https://liuyihua2015.github.io/tags/Symbol/"},{"name":"链接器","slug":"链接器","permalink":"https://liuyihua2015.github.io/tags/%E9%93%BE%E6%8E%A5%E5%99%A8/"},{"name":"Alamofire","slug":"Alamofire","permalink":"https://liuyihua2015.github.io/tags/Alamofire/"},{"name":"swift","slug":"swift","permalink":"https://liuyihua2015.github.io/tags/swift/"},{"name":"Hexo","slug":"Hexo","permalink":"https://liuyihua2015.github.io/tags/Hexo/"}]}