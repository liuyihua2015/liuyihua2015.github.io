{"meta":{"title":"LIU YIHUA`S WORLD","subtitle":"移动端开发工程师","description":"LIU YIHUA`S WORLD 一个记录记录学习和生活的交流平台","author":"liuyihua","url":"https://liuyihua2015.github.io","root":"/"},"pages":[{"title":"","date":"2022-04-14T06:37:01.775Z","updated":"2022-04-14T06:37:01.751Z","comments":true,"path":"自动打包.html","permalink":"https://liuyihua2015.github.io/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85.html","excerpt":"","text":"123456\\n版本号：$&#123; appVersion&#125;\\n源代码分支:$&#123; branch&#125;\\n默认运行环境: $(runtimeEnv&#125;\\n构建时间:$&#123;appUpdated)\\n$(appUpdateDescription)\\nApp下载地址: $(appBuildURL&#125;\\n"},{"title":"404 Not Found：该页无法显示","date":"2022-04-13T05:45:45.101Z","updated":"2021-12-09T06:32:05.614Z","comments":false,"path":"/404.html","permalink":"https://liuyihua2015.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2022-04-13T05:45:45.099Z","updated":"2021-12-09T06:32:05.615Z","comments":false,"path":"about/index.html","permalink":"https://liuyihua2015.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2022-04-13T05:45:45.099Z","updated":"2021-12-09T06:32:05.615Z","comments":false,"path":"books/index.html","permalink":"https://liuyihua2015.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-04-13T05:45:45.101Z","updated":"2021-12-09T06:32:05.615Z","comments":false,"path":"categories/index.html","permalink":"https://liuyihua2015.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-04-13T05:45:45.100Z","updated":"2021-12-09T06:32:05.615Z","comments":true,"path":"links/index.html","permalink":"https://liuyihua2015.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-04-13T05:45:45.092Z","updated":"2021-12-09T06:32:05.615Z","comments":false,"path":"repository/index.html","permalink":"https://liuyihua2015.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-04-13T05:45:45.100Z","updated":"2021-12-09T06:32:05.615Z","comments":false,"path":"tags/index.html","permalink":"https://liuyihua2015.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"终端操作命令详解","slug":"终端操作命令详解”","date":"2022-05-12T06:55:33.000Z","updated":"2022-05-12T07:24:46.259Z","comments":true,"path":"2022/05/12/终端操作命令详解”/","link":"","permalink":"https://liuyihua2015.github.io/2022/05/12/%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%E2%80%9D/","excerpt":"","text":"快捷键 快捷键 描述 Ctrl + k 删除从光标到行尾 Ctrl + u 删除从光标到行首 Ctrl + w 从光标向前一个单词剪切到剪贴板 Alt + d 从光标向后删除一个单词 Ctrl + d 删除光标下一个字母 Ctrl + h 删除光标前一个字母 Alt + t swap（当前单词，上一个单词） Ctrl + t swap（当前字母，上一个字母） Ctrl + u 删除从光标到行首 Ctrl + y 粘贴上一次删除的文本 Alt + c 大写当前字母，并移动光标到单词尾 Alt + u 大写从当光标到单词尾 Alt + 1 小写从当光标到单词尾 Ctrl + r 向后搜索历史命令 Ctrl + g 退出搜索 Ctrl + p 历史中上一个命令 Ctrl + n 历史中下一个命令 Alt + . 上—命令的最后—单词 Ctrl + I 清屏 Ctrl + s 停止输出（在zsh中为向前搜索历史命令） Ctrl + q 继续输出 Ctrl + c 终止当前命令 Ctrl + z 挂起当前命令 Ctrl + d 结束输入（产生一个EOF） Ctrl + a 移动光标到行首 Ctrl + e 移动光标到行尾 Alt + b 移动光标后退一个单词（词首） Alt + f 移动光标前进一个单词（词首） Ctrl + f 光标前进一个字母 Ctrl + b 光标后退一个字母 Ctrl + xx 当前位置与行首之间光标切换 Ctrl + - 撤消 Alt + r 取消更改，并恢复历史记录中的行（还原） 交换光标前的最后两个单词 Esc + t ii 重复上一条命令 !n 交换光标前的最后两个单词 !n:m 重复最后一个命只取参数从n到m,例如：！:2-4 !n:$ 重复最后一个命只取参数从n到最后，例如:！:2-$ **!n:p ** 从n开始打印最后一个命令，例如：！:4 !string 从string开始打印最后一个命令 !:q 引用最后一个命令 !$ 上一个命令的最后一个参数 !* 先前命令的所有参数","categories":[{"name":"Mac","slug":"Mac","permalink":"https://liuyihua2015.github.io/categories/Mac/"}],"tags":[{"name":"终端","slug":"终端","permalink":"https://liuyihua2015.github.io/tags/%E7%BB%88%E7%AB%AF/"}]},{"title":"使用Jenkins实现iOS自动化打包","slug":"使用Jenkins实iOS现自动化打包","date":"2022-04-14T13:29:59.000Z","updated":"2022-04-21T02:39:22.025Z","comments":true,"path":"2022/04/14/使用Jenkins实iOS现自动化打包/","link":"","permalink":"https://liuyihua2015.github.io/2022/04/14/%E4%BD%BF%E7%94%A8Jenkins%E5%AE%9EiOS%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85/","excerpt":"","text":"开发周期刚刚结束不久，研究了一下使用Jenkins实现iOS自动化打包以及上传，包括App Store和像蒲公英这样的一些第三方平台。 写这篇文章的本意是想记录下我在搭建及使用 Jenkins 的所遇到的问题以及解决方法。 至于如何搭建和使用 Jenkins,主要参考的文章来自：iOS-Jenkins+git实现自动化打包, 请关注和感谢这位同学； Mac 安装Jenkins通过brew安装 安装最新版本 1brew install jenkins 安装 LTS 版本 1brew install jenkins-lts 下载 pkg 安装打开Jenkins官网， 点击Downloads 选择要安装的版本安装即可。更多的安装方式可以参考Jenkins官网：www.jenkins.io/zh/doc/book… 安装 Java 环境Jenkins需要依赖 Java 环境的，根据安装的Jenkins 依赖的Java版本进行安装。首先检查电脑是否配置了Java环境 1java -version 如果没有，可以去这个地址 www.oracle.com/technetwork… 下载JDK。安装完之后通过 java -version 查看安装的版本。","categories":[{"name":"自动化打包","slug":"自动化打包","permalink":"https://liuyihua2015.github.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85/"}],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://liuyihua2015.github.io/tags/Jenkins/"},{"name":"自动化打包","slug":"自动化打包","permalink":"https://liuyihua2015.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85/"},{"name":"钉钉机器人","slug":"钉钉机器人","permalink":"https://liuyihua2015.github.io/tags/%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA/"}]},{"title":"iOS高级进阶:链接与Symbol","slug":"iOS高级进阶-链接与Symbol","date":"2022-04-01T02:12:51.000Z","updated":"2022-04-06T09:35:16.929Z","comments":true,"path":"2022/04/01/iOS高级进阶-链接与Symbol/","link":"","permalink":"https://liuyihua2015.github.io/2022/04/01/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6-%E9%93%BE%E6%8E%A5%E4%B8%8ESymbol/","excerpt":"","text":"系列文章：iOS高级进阶 前言本篇文章学习的主要内容为:多环境配置，xconfig文件冲突解决，Mach-O与链接器，符号的种类与作用，strip命令 一、多环境配置 Project：包含了项目所有的代码，资源文件，所有信息。 Targets：对指定代码和资源文件的具体构建方式。 Scheme：对指定Target的环境配置。 我们创建好项目，项目默认两个环境Debug和Release环境，在开发过程中我们也会有两套或者多套服务器环境，每个环境的地址不同，粗糙的写法就是如下图所示： 12345#if DEBUG//开发环境#else//正式环境#endif 它只能满足两种环境，无法适应多环境，下面我们介绍几种多环境配置方法 （一）Targets进行多环境配置：1.在项目时可以创建多个Target，复制一个target，成为新的dev_target 2.修改一下新的target 的 bundle Id 3.修改一下新的target的info.plist文件 4.两个target 都可以运行，并且是不同的项目，可以通过 配置不同 的icon 进行区分 5.在build setting 中 设置宏 5.1 OC宏配置 5.2 swift 宏配置 1234567//开发环境#if DEVELOPMENT == 1//生产环境#elif TARGET_VERSION == 0#endif 6.总结 这种多环境配置有一个缺点: 会存在多info.plst文件，环境多了，配置会比较乱 （二）对指定Target进行多Schems的环境配置，进行不同的环境编译：1.在Project中，首先添加需要的 Configuraction 2.创建不同的schems，指定他们的Build Configuraction 3.在build setting 中 设置宏 12345678910//开发环境 可编译不同的请求地址#if TARGET_VERSION == 0//生产环境#elif TARGET_VERSION == 1//测试环境#elif TARGET_VERSION == 2#endif 4.这样可以愉快的开发了 总结：这种方式虽然不会存在多info.plst文件，但是环境多了，配置会比较乱, 修改的代码都在一起，影响主工程代码（这里可以开分支开发，不污染主分支，最后合并代码） （三）.xcconfig多环境配置：初始.xcconfigxcconfig文件正如其名字一样，就是xcode里的config文件。 我们在开发过程中，需要配置一些参数，这些都可以在xcode工程的setting对项目进行配置，xcconfig就是将这些配置项以文件的形式独立出来，方便共享与配置。比如两个项目用到相同的配置，那么只需要在xcode中选择对应的xcconfig文件即可，方便与灵活共，我们经常使用的 cocoapods 对第三方进行管理，其实就是通过.xcconfig文件进行管理的，创建好cocoapods会自动根据环境帮我们生成好.xcconfig文件。 .xcconfig文件内容是已Key-Value形式存在，’=’左侧是key值，右侧为value值 1、创建config文件 注意命名规则：.xcconfig文件所在的文件夹名称+项目名称+.环境名称 2、编辑文件内容： 3、回到Project中，将配置文件和schems 关联起来 4、在info.plist中，配置 5.需要在 Build Settings 中的 User-Defined 添加 自定义宏定义 6、在项目中简单使用 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; NSString *path = [NSBundle.mainBundle pathForResource:@&quot;Info&quot; ofType:@&quot;plist&quot;]; NSDictionary *infoDic = [[NSDictionary alloc] initWithContentsOfFile:path]; NSLog(@&quot;%@&quot;,infoDic[@&quot;HOST_URL&quot;]); return YES;&#125; 总结：这种设置方式要比上面的简化了不少，但是.xcconfig文件的功能不只有这些，下面我们扩展一下 二、xconfig扩展与文件冲突解决（一）.xcconfig扩展上面我们介绍了简单的配置URL，.xcconfig文件是可以配置Build Settings里面的内容，比如我们平时配置动态库，静态库时，要配置到Other Link Flags，通过.xcconfig我们可以直接配置，例如：我们配置AFN 在.xcconfig中写如下代码 12HOST_URL=127.0.0.1OTHER_LDFLAGS = -framework &quot;AFNetworking&quot; 项目build之后，在Build Settings中查看 Other Link Flags，发现写的已经配置进去了 过上面的操作我们可以知道，Build Settings的所有配置都是可以通过.xcconfig文件进行管理的。我们来解释下.xcconfig的内容：OTHER_LDFLAGS是Build Settings里面的一个缩写，其它设置缩写是什么呢？ 推荐个地址：Xcode Build Settings 比如我们想配置Header Search Paths，它对应的缩写：HEADER_SEARCH_PATHS （二）.xcconfig文件冲突问题一 我们项目都会通过cocoapods管理第三方，最开始介绍.xcconfig的时候，说了pods会自动帮我们生成.xcconfig文件，那此时项目中就会有4个.xccongig文件，直接运行会报错 解决办法：在我们自己的xccongig文件中，通过 #include 引入cocoapods的xccongig文件 1234#include &quot;Pods/Target Support Files/Pods-LoginApp/Pods-LoginApp.debug.xcconfig&quot;HOST_URL = 127.0.0.1OTHER_LDFLAGS = -framework &quot;AFNetworking&quot; 问题二 我们看到Pods生成的.xcconfig里也会有OTHER_LDFLAGS，我们自己写的.xcconfig中也存在OTHER_LDFLAGS，我们再去看下项目的Other Linker Flags，发现Pods生成的.xcconfig没有生效，那么怎么才能让我们写的和Pods生成的都生效呢？ 使用 inherited 进行集成 12345678910#include &quot;Pods/Target Support Files/Pods-LoginApp/Pods-LoginApp.debug.xcconfig&quot;HOST_URL = 127.0.0.1// ld// key-value// OTHER_LDFLAGS 缩写OTHER_LDFLAGS = $(inherited) -framework &quot;AFNetworking&quot;HEADER_SEARCH_PATHS = /use/info/inclue 总结 我们通过.xcconfig对项目进行配置，我们可以通过.xcconfig+Scheme方式进行统一管理，这样既省时，又省事。 三、Mach-O与链接器Mach-O初识【Mach-O定义】：Mach-O(Mach Object)是macOS、iOS、iPadOS存储程序和库的文件格式。对应系统通过应用二进制接口(application binary interface，缩写为ABI)来运行该格式的文件。 Mach-O格式用来替代BSD系统的a.out格式。Mach-O文件格式保存了在编译过程和链接过程中产生的机器代码和数据，从而为静态链接和动态链接的代码提供了单一文件格式。 查看项目的Mach-O文件1、当我们运行项目是，项目会生成一个.app文件 2、右击查看包内容，会发现里面有个可执行文件，这个就是mach-o文件 3、通过 file 命令来查看MachODome文件类型（这里用的真机，所以是arm64架构。） 执行文件的调用过程大致如下： 1.调用fork函数，创建一个process 2.调用execve或其衍生函数，在该进程上加载，执行我们的Mach-O文件 当我们调用时execve(程序加载器)，内核实际上在执行以下操作: 1.将文件加载到内存 2.开始分析Mach-O中的mach_header，以确认它是有效的Mach-O文件 分析Mach-O文件Mach-O组成1. Mach-O 结构： Mach-O的主要组成部分：Mach Header、Load Command、Data(__TEXT、__DATA、符号表) 2. Mach HeaderMach Header 里有 Mach-O 的CUP信息，以及Load Command的信息。可以使用 otool 或 objdump 命令来查看 otool命令：otool -v -h MachODome objdump命令：objdump --macho --private-headers MachODome 下面就是使用objdump命令，查看的详情结果如下：在改文件中已经指定好项目入口，和已经需要引用的系统依赖库信息： 3. Load CommandLoad Command 包含 Mach-O里的命令类型信息，名称和二进制文件的位置（类似一本书的目录）。同样可以使用 otool 或 objdump 命令来查看 otool：otool -v -l a.out objdump: objdump --macho --private-headers MachOApp(注意这里是 headers) 结果如下： 4. DataData 由 Segment 的数据组成，是 Mach-O 占比最多的部分，有代码有数据，比如符号表（类似一本书的具体内容）。 Data 共三个 Segment，__TEXT、__DATA、__LINKEDIT。其中 __TEXT 和 __DATA 对应一个或多个 Section，__LINKEDIT 没有 Section，需要配合 LC_SYMTAB 来解析 symbol table 和 string table。这些里面是 Mach-O 的主要数据。 使用 xcrun size 命令来查看 Data 内容的分部 xcrun size 命令：xcrun size -x -l -m MachOApp 结果如下： 四、符号的种类与作用五、strip命令","categories":[{"name":"iOS高级进阶","slug":"iOS高级进阶","permalink":"https://liuyihua2015.github.io/categories/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"Symbol","slug":"Symbol","permalink":"https://liuyihua2015.github.io/tags/Symbol/"},{"name":"链接器","slug":"链接器","permalink":"https://liuyihua2015.github.io/tags/%E9%93%BE%E6%8E%A5%E5%99%A8/"}]},{"title":"Alamofire-初体验","slug":"Alamofire-初体验","date":"2021-12-17T02:59:23.000Z","updated":"2022-04-21T02:39:22.024Z","comments":true,"path":"2021/12/17/Alamofire-初体验/","link":"","permalink":"https://liuyihua2015.github.io/2021/12/17/Alamofire-%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"","text":"对于iOS开发者来说，AFNetworking是我们大家所熟知的，而Alamofire呢？Alamofire框架其实就是AFNetworking兄弟，出自于同一个作者。既是同一个作者，那么他们的使用方法，框架结构上应该也是保持一致的。AFNetworking、Alamofire 一、回顾苹果原生网络请求一、网络请求步骤 设置请求url 设置URLRequest对象，配置请求相关信息 创建会话配置URLSessionConfiguration 创建会话URLSession 创建任务和设置请求回调，并发起请求 一般通过以上几个步来完成网络请求，当然要根据不同应用场景来配置请求属性。 二、体验发起一个请求： 123456789101112131415161718func responseData() &#123; let url = &quot;http://onapp.yahibo.top/public/?s=api/test/list&quot; Alamofire.request(url).responseJSON &#123; (response) in switch response.result&#123; case .success(let json): print(&quot;json:\\(json)&quot;) let dict = json as! Dictionary&lt;String, Any&gt; let list = dict[&quot;data&quot;] as! Array&lt;AnyObject&gt; guard let result = [UserModel1].deserialize(from: list) else&#123;return&#125; self.observable.onNext(result as [Any]) break case .failure(let error): print(&quot;error:\\(error)&quot;) break &#125; &#125;&#125; responseJSON为相应类型，指定为json数据类型 response是Alamofire对服务器响应结果的封装 使用常规解包获取数据headimg 通过HandyJSON转换为模型数据，供UI展示 直接通过Alamofire发起请求通过一个闭包返回请求结果，不需要二次封装使用简单。这里我们没有标明请求类型，没有请求参数，那Alamofire是如何封装这些请求参数的呢，点击进入查看方法定义： 这里已经提供了请求所需要的参数，并设置了默认值，因此外界在没有指定方法时默认为get方式。根据实际开发需求设置响应的参数： 1Alamofire.request(url,method: .post,parameters: [&quot;page&quot;:&quot;1&quot;,&quot;size&quot;:&quot;20&quot;]).responseJSON 这是我们开发中常见的设置请求方式，请求参数，这里的url支持多种数据类型，可以是String、URL、URLRequest等类型，为什么这么设计呢？因为在项目中可能当前我们跟前有一个String类型的连接，也有可能是个URL类型的连接，这时候在不需要转换的情况下就可以直接使用，方便快捷，更加灵活。 三、URLSession同样在Alamofire中也是对URLSession封装的，在OC中为NSURLSession，其实是一样的。一般网络请求分三个步骤： 1、设置URL请求地址1let url = URL.init(string: &quot;协议://主机地址/路径/参数1&amp;参数2&quot;)! 协议：指定http协议还是https协议 主机：即服务器地址ip地址或绑定ip的域名 路径：项目在服务器上的位置 参数：即get参数拼接在连接上 2、设置URLRequest属性1234567var request = URLRequest.init(url: url)request.httpMethod = HTTPMethod.post.rawValuerequest.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)let postData = [&quot;username&quot;:&quot;hibo&quot;,&quot;password&quot;:&quot;123456&quot;]request.httpBody = try?JSONSerialization.data(withJSONObject: postData, options: [])request.timeoutInterval = 30request.cachePolicy = .useProtocolCachePolicy httpMethod设置请求方式post或get setValue设置请求头信息 httpBody设置请求参数，参数打包在请求体中 timeoutInterval设置请求超时时间 cachePolicy设置网络请求缓存策略 通过以上的参数设置，能够感受到发送一次请求是多么不容易，因此网络请求是必须要被封装的 3、发起请求123456789URLSession.shared.dataTask(with: request) &#123; (data, response, error) in print(&quot;*******网络请求*******&quot;) do &#123; let list = try JSONSerialization.jsonObject(with: data!, options: .allowFragments) print(list) &#125;catch&#123; print(error) &#125;&#125;.resume() URLSession.shared为全局共享单例会话对象 调用dataTask创建网络请求任务 resume默认为挂起状态，调用重新启动网络请求任务 data：请求到的数据流，通过JSONSerialization序列化为json格式使用 四、URLSessionConfiguration在URLSession.shared中内部已经配置了该项，此项为会话配置项，一般使用都会进行配置以适用于不同场景。查看该类如下： 1234open class var `default`: URLSessionConfiguration &#123; get &#125;open class var ephemeral: URLSessionConfiguration &#123; get &#125;@available(iOS 8.0, *)open class func background(withIdentifier identifier: String) -&gt; URLSessionConfiguration default：默认模式，常用模式，在该模式下系统会创建持久化缓存，并在用户的钥匙串中保存证书 ephemeral：不支持持久性存储，所有内容的会随着session的生命周期结束而释放 background：与default模式类似，在该模式下会创建一个独立线程来传输网络请求数据，可以在后台乃至APP关闭的时候也可以进行数据传输 创建一个会话： 1234567891011let configuration = URLSessionConfiguration.background(withIdentifier: &quot;request_id&quot;)let session = URLSession.init(configuration: configuration, delegate: self, delegateQueue: OperationQueue.main)session.dataTask(with: request) &#123; (data, response, error) in print(&quot;*******网络请求*******&quot;) do &#123; let list = try JSONSerialization.jsonObject(with: data!, options: .allowFragments) print(list) &#125;catch&#123; print(error) &#125;&#125;.resume() 设置一个唯一会话标识，通过标识来区分不同的会话任务 遵循URLSessionDelegate代理，实现代理方法，在本类中监控任务进度 下载任务： 123let configuration = URLSessionConfiguration.background(withIdentifier: &quot;request_id&quot;)let session = URLSession.init(configuration: configuration, delegate: self, delegateQueue: OperationQueue.main)session.downloadTask(with: url).resume() 注意在使用background模式时一定要开启后台下载权限，否则无法完成后台下载并回调数据。需要以下两步才能完成： 1、开启后台下载权限 12345var backgroundHandler: (()-&gt;Void)? = nil//设置此处开启后台下载权限func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -&gt; Void) &#123; self.backgroundHandler = completionHandler&#125; 2、实现SessionDelegate代理方法，调用闭包方法，通知系统更新屏幕 1234567func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) &#123; print(&quot;后台任务下载回来&quot;) DispatchQueue.main.async &#123; guard let appDelegate = UIApplication.shared.delegate as? AppDelegate, let backgroundHandle = appDelegate.backgroundHandler else &#123; return &#125; backgroundHandle() &#125;&#125; 苹果官方给出需要实现以上两个方法来完成后台下载，通知系统及时更新屏幕。官方文档","categories":[{"name":"网络框架","slug":"网络框架","permalink":"https://liuyihua2015.github.io/categories/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Alamofire","slug":"Alamofire","permalink":"https://liuyihua2015.github.io/tags/Alamofire/"},{"name":"swift","slug":"swift","permalink":"https://liuyihua2015.github.io/tags/swift/"}]},{"title":"Hexo 有效的插件","slug":"Hexo 实现实时预览","date":"2021-12-17T02:59:23.000Z","updated":"2022-04-01T09:36:04.622Z","comments":true,"path":"2021/12/17/Hexo 实现实时预览/","link":"","permalink":"https://liuyihua2015.github.io/2021/12/17/Hexo%20%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E9%A2%84%E8%A7%88/","excerpt":"","text":"一、实现实时预览编辑在用了一段时间 Hexo 后, 发现写 Hexo 文章时需要到在线的 Markdown 编辑器中实时预览, 感觉还是有些不方便. 在网上一番寻找之后, 发现了一个插件: hexo-browsersync, 这是一个移植插件, 项目主页上基本没有过多的介绍. 下面写一些我自己使用的心得吧. Hexo-Browsersync 使用方法首先在项目目录下安装 hexo-browsersync 插件 12$ cd hexo_project/$ npm install hexo-browsersync --save 然后运行 hexo server, 看到以下内容就说明启动成功啦. 123456789$ hexo s[BS] Access URLs: -------------------------------------- UI: http://localhost:3001 -------------------------------------- UI External: http://192.168.191.1:3001 --------------------------------------INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 其中 3001 端口是 browsersync 的配置页面, 4000 端口就是我们的调试页面了. 参考文章 Hexo Server 的一个迷の bug – 潘佳邦 https://github.com/hexojs/hexo-browsersync/issues/12 二、图片插件插件hexo-renderer-marked解决了这个问题。可以只用npm install hexo-renderer-marked命令直接安装，之后在config.yaml中更改配置如下： 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 之后就可以在使用 1![](image.jpg) 的方式愉快的插入图片了。 我们做了这么多都是为了方便，那么为什么不再方便一点呢。","categories":[{"name":"心得","slug":"心得","permalink":"https://liuyihua2015.github.io/categories/%E5%BF%83%E5%BE%97/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://liuyihua2015.github.io/tags/Hexo/"}]}],"categories":[{"name":"Mac","slug":"Mac","permalink":"https://liuyihua2015.github.io/categories/Mac/"},{"name":"自动化打包","slug":"自动化打包","permalink":"https://liuyihua2015.github.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85/"},{"name":"iOS高级进阶","slug":"iOS高级进阶","permalink":"https://liuyihua2015.github.io/categories/iOS%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/"},{"name":"网络框架","slug":"网络框架","permalink":"https://liuyihua2015.github.io/categories/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"},{"name":"心得","slug":"心得","permalink":"https://liuyihua2015.github.io/categories/%E5%BF%83%E5%BE%97/"}],"tags":[{"name":"终端","slug":"终端","permalink":"https://liuyihua2015.github.io/tags/%E7%BB%88%E7%AB%AF/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://liuyihua2015.github.io/tags/Jenkins/"},{"name":"自动化打包","slug":"自动化打包","permalink":"https://liuyihua2015.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85/"},{"name":"钉钉机器人","slug":"钉钉机器人","permalink":"https://liuyihua2015.github.io/tags/%E9%92%89%E9%92%89%E6%9C%BA%E5%99%A8%E4%BA%BA/"},{"name":"Symbol","slug":"Symbol","permalink":"https://liuyihua2015.github.io/tags/Symbol/"},{"name":"链接器","slug":"链接器","permalink":"https://liuyihua2015.github.io/tags/%E9%93%BE%E6%8E%A5%E5%99%A8/"},{"name":"Alamofire","slug":"Alamofire","permalink":"https://liuyihua2015.github.io/tags/Alamofire/"},{"name":"swift","slug":"swift","permalink":"https://liuyihua2015.github.io/tags/swift/"},{"name":"Hexo","slug":"Hexo","permalink":"https://liuyihua2015.github.io/tags/Hexo/"}]}