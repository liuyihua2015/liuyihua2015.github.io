{"meta":{"title":"LIU YIHUA`S WORLD","subtitle":"移动端开发工程师","description":"LIU YIHUA`S WORLD 一个记录记录学习和生活的交流平台","author":"liuyihua","url":"https://liuyihua2015.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-12-09T06:58:39.039Z","updated":"2021-12-09T06:32:05.614Z","comments":false,"path":"/404.html","permalink":"https://liuyihua2015.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-12-09T06:58:39.023Z","updated":"2021-12-09T06:32:05.615Z","comments":false,"path":"about/index.html","permalink":"https://liuyihua2015.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-12-09T06:58:39.006Z","updated":"2021-12-09T06:32:05.615Z","comments":false,"path":"books/index.html","permalink":"https://liuyihua2015.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-12-09T06:58:38.990Z","updated":"2021-12-09T06:32:05.615Z","comments":false,"path":"categories/index.html","permalink":"https://liuyihua2015.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-12-09T06:58:38.975Z","updated":"2021-12-09T06:32:05.615Z","comments":true,"path":"links/index.html","permalink":"https://liuyihua2015.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-12-09T06:58:38.958Z","updated":"2021-12-09T06:32:05.615Z","comments":false,"path":"repository/index.html","permalink":"https://liuyihua2015.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-12-09T06:58:38.941Z","updated":"2021-12-09T06:32:05.615Z","comments":false,"path":"tags/index.html","permalink":"https://liuyihua2015.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hexo 有效的插件","slug":"Hexo 实现实时预览","date":"2021-12-17T02:59:23.000Z","updated":"2021-12-17T08:14:29.262Z","comments":true,"path":"2021/12/17/Hexo 实现实时预览/","link":"","permalink":"https://liuyihua2015.github.io/2021/12/17/Hexo%20%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E9%A2%84%E8%A7%88/","excerpt":"","text":"一、实现实时预览编辑在用了一段时间 Hexo 后, 发现写 Hexo 文章时需要到在线的 Markdown 编辑器中实时预览, 感觉还是有些不方便. 在网上一番寻找之后, 发现了一个插件: hexo-browsersync, 这是一个移植插件, 项目主页上基本没有过多的介绍. 下面写一些我自己使用的心得吧. Hexo-Browsersync 使用方法首先在项目目录下安装 hexo-browsersync 插件 12$ cd hexo_project/$ npm install hexo-browsersync --save 然后运行 hexo server, 看到以下内容就说明启动成功啦. 123456789$ hexo s[BS] Access URLs: -------------------------------------- UI: http://localhost:3001 -------------------------------------- UI External: http://192.168.191.1:3001 --------------------------------------INFO Start processingINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 其中 3001 端口是 browsersync 的配置页面, 4000 端口就是我们的调试页面了. 参考文章 Hexo Server 的一个迷の bug – 潘佳邦 https://github.com/hexojs/hexo-browsersync/issues/12 二、图片插件插件hexo-renderer-marked解决了这个问题。可以只用npm install hexo-renderer-marked命令直接安装，之后在config.yaml中更改配置如下： 1234post_asset_folder: truemarked: prependRoot: true postAsset: true 之后就可以在使用 1![](image.jpg) 的方式愉快的插入图片了。 我们做了这么多都是为了方便，那么为什么不再方便一点呢。","categories":[{"name":"心得","slug":"心得","permalink":"https://liuyihua2015.github.io/categories/%E5%BF%83%E5%BE%97/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://liuyihua2015.github.io/tags/Hexo/"}]},{"title":"Alamofire-初体验","slug":"Alamofire-初体验","date":"2021-12-17T02:59:23.000Z","updated":"2021-12-17T08:16:27.994Z","comments":true,"path":"2021/12/17/Alamofire-初体验/","link":"","permalink":"https://liuyihua2015.github.io/2021/12/17/Alamofire-%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"","text":"对于iOS开发者来说，AFNetworking是我们大家所熟知的，而Alamofire呢？Alamofire框架其实就是AFNetworking兄弟，出自于同一个作者。既是同一个作者，那么他们的使用方法，框架结构上应该也是保持一致的。AFNetworking、Alamofire 一、回顾苹果原生网络请求一、网络请求步骤 设置请求url 设置URLRequest对象，配置请求相关信息 创建会话配置URLSessionConfiguration 创建会话URLSession 创建任务和设置请求回调，并发起请求 一般通过以上几个步来完成网络请求，当然要根据不同应用场景来配置请求属性。 二、体验发起一个请求： 123456789101112131415161718func responseData() &#123; let url = &quot;http://onapp.yahibo.top/public/?s=api/test/list&quot; Alamofire.request(url).responseJSON &#123; (response) in switch response.result&#123; case .success(let json): print(&quot;json:\\(json)&quot;) let dict = json as! Dictionary&lt;String, Any&gt; let list = dict[&quot;data&quot;] as! Array&lt;AnyObject&gt; guard let result = [UserModel1].deserialize(from: list) else&#123;return&#125; self.observable.onNext(result as [Any]) break case .failure(let error): print(&quot;error:\\(error)&quot;) break &#125; &#125;&#125; responseJSON为相应类型，指定为json数据类型 response是Alamofire对服务器响应结果的封装 使用常规解包获取数据headimg 通过HandyJSON转换为模型数据，供UI展示 直接通过Alamofire发起请求通过一个闭包返回请求结果，不需要二次封装使用简单。这里我们没有标明请求类型，没有请求参数，那Alamofire是如何封装这些请求参数的呢，点击进入查看方法定义： 这里已经提供了请求所需要的参数，并设置了默认值，因此外界在没有指定方法时默认为get方式。根据实际开发需求设置响应的参数： 1Alamofire.request(url,method: .post,parameters: [&quot;page&quot;:&quot;1&quot;,&quot;size&quot;:&quot;20&quot;]).responseJSON 这是我们开发中常见的设置请求方式，请求参数，这里的url支持多种数据类型，可以是String、URL、URLRequest等类型，为什么这么设计呢？因为在项目中可能当前我们跟前有一个String类型的连接，也有可能是个URL类型的连接，这时候在不需要转换的情况下就可以直接使用，方便快捷，更加灵活。 三、URLSession同样在Alamofire中也是对URLSession封装的，在OC中为NSURLSession，其实是一样的。一般网络请求分三个步骤： 1、设置URL请求地址1let url = URL.init(string: &quot;协议://主机地址/路径/参数1&amp;参数2&quot;)! 协议：指定http协议还是https协议 主机：即服务器地址ip地址或绑定ip的域名 路径：项目在服务器上的位置 参数：即get参数拼接在连接上 2、设置URLRequest属性1234567var request = URLRequest.init(url: url)request.httpMethod = HTTPMethod.post.rawValuerequest.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)let postData = [&quot;username&quot;:&quot;hibo&quot;,&quot;password&quot;:&quot;123456&quot;]request.httpBody = try?JSONSerialization.data(withJSONObject: postData, options: [])request.timeoutInterval = 30request.cachePolicy = .useProtocolCachePolicy httpMethod设置请求方式post或get setValue设置请求头信息 httpBody设置请求参数，参数打包在请求体中 timeoutInterval设置请求超时时间 cachePolicy设置网络请求缓存策略 通过以上的参数设置，能够感受到发送一次请求是多么不容易，因此网络请求是必须要被封装的 3、发起请求123456789URLSession.shared.dataTask(with: request) &#123; (data, response, error) in print(&quot;*******网络请求*******&quot;) do &#123; let list = try JSONSerialization.jsonObject(with: data!, options: .allowFragments) print(list) &#125;catch&#123; print(error) &#125;&#125;.resume() URLSession.shared为全局共享单例会话对象 调用dataTask创建网络请求任务 resume默认为挂起状态，调用重新启动网络请求任务 data：请求到的数据流，通过JSONSerialization序列化为json格式使用 四、URLSessionConfiguration在URLSession.shared中内部已经配置了该项，此项为会话配置项，一般使用都会进行配置以适用于不同场景。查看该类如下： 1234open class var `default`: URLSessionConfiguration &#123; get &#125;open class var ephemeral: URLSessionConfiguration &#123; get &#125;@available(iOS 8.0, *)open class func background(withIdentifier identifier: String) -&gt; URLSessionConfiguration default：默认模式，常用模式，在该模式下系统会创建持久化缓存，并在用户的钥匙串中保存证书 ephemeral：不支持持久性存储，所有内容的会随着session的生命周期结束而释放 background：与default模式类似，在该模式下会创建一个独立线程来传输网络请求数据，可以在后台乃至APP关闭的时候也可以进行数据传输 创建一个会话： 1234567891011let configuration = URLSessionConfiguration.background(withIdentifier: &quot;request_id&quot;)let session = URLSession.init(configuration: configuration, delegate: self, delegateQueue: OperationQueue.main)session.dataTask(with: request) &#123; (data, response, error) in print(&quot;*******网络请求*******&quot;) do &#123; let list = try JSONSerialization.jsonObject(with: data!, options: .allowFragments) print(list) &#125;catch&#123; print(error) &#125;&#125;.resume() 设置一个唯一会话标识，通过标识来区分不同的会话任务 遵循URLSessionDelegate代理，实现代理方法，在本类中监控任务进度 下载任务： 123let configuration = URLSessionConfiguration.background(withIdentifier: &quot;request_id&quot;)let session = URLSession.init(configuration: configuration, delegate: self, delegateQueue: OperationQueue.main)session.downloadTask(with: url).resume() 注意在使用background模式时一定要开启后台下载权限，否则无法完成后台下载并回调数据。需要以下两步才能完成： 1、开启后台下载权限 12345var backgroundHandler: (()-&gt;Void)? = nil//设置此处开启后台下载权限func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -&gt; Void) &#123; self.backgroundHandler = completionHandler&#125; 2、实现SessionDelegate代理方法，调用闭包方法，通知系统更新屏幕 1234567func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) &#123; print(&quot;后台任务下载回来&quot;) DispatchQueue.main.async &#123; guard let appDelegate = UIApplication.shared.delegate as? AppDelegate, let backgroundHandle = appDelegate.backgroundHandler else &#123; return &#125; backgroundHandle() &#125;&#125; 苹果官方给出需要实现以上两个方法来完成后台下载，通知系统及时更新屏幕。官方文档","categories":[{"name":"网络框架","slug":"网络框架","permalink":"https://liuyihua2015.github.io/categories/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Alamofire","slug":"Alamofire","permalink":"https://liuyihua2015.github.io/tags/Alamofire/"},{"name":"swift","slug":"swift","permalink":"https://liuyihua2015.github.io/tags/swift/"}]}],"categories":[{"name":"心得","slug":"心得","permalink":"https://liuyihua2015.github.io/categories/%E5%BF%83%E5%BE%97/"},{"name":"网络框架","slug":"网络框架","permalink":"https://liuyihua2015.github.io/categories/%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://liuyihua2015.github.io/tags/Hexo/"},{"name":"Alamofire","slug":"Alamofire","permalink":"https://liuyihua2015.github.io/tags/Alamofire/"},{"name":"swift","slug":"swift","permalink":"https://liuyihua2015.github.io/tags/swift/"}]}